<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="google-site-verification" content="acAEm8WsV7YCaPsZ2zflrzGZZB5r5fIRitxA4GkQ14Q"><meta name="description" content="Software development - techniques, opinions, thoughts"><title>Prevent re-entrancy on long running async methods | Code Ronin</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/dark.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml,rss2.xml"><script src="https://www.googletagmanager.com/gtag/js?id=G-8L9Y2PVNJE"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-8L9Y2PVNJE');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Prevent re-entrancy on long running async methods</h1><a id="logo" href="/.">Code Ronin</a><p class="description">Random thoughts about software development</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a><a href="/Legal/"><i class="fa fa-legal"> Legal</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">Prevent re-entrancy on long running async methods</h1><div class="post-meta">2020-12-17</div><div class="post-content"><p>Sometimes you got async methods you know will run for some time and you want to prevent them from being called while a previous call has not yet finished.</p>
<p>For example, imagine a tool that creates a visualization of the storage use per folder on your harddrive. In order to do that, it has to scan all folders recursively to get the size data. This is a very long task indeed, probably on the order of minutes. </p>
<p>Now while that scanning process is running, it makes hardly any sense to start another one, in fact doing so would slow down the first. Of course, you can prevent that on the UI level, by just disabling the command bound to the “Scan” button once a scan has started and re-enabling it once the scan has finished.</p>
<p>But what if you are writing the API of the file-system scanner, but not the UI? In other words, you got no control over the UI, yet you still want to prevent such simultaneous calls to your scan method?</p>
<p>Let’s say you expose the following API:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FileSystemFacade</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> IFolder _rootFolder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... other stuff like the constructor etc.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task&lt;<span class="built_in">long</span>&gt; <span class="title">GetTotalSizeAsync</span>(<span class="params"></span>)</span> =&gt; _rootFolder.GetSizeAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>where <code>IFolder.GetSizeAsync()</code> is the method that can run for quite some time.</p>
<p>Remember that Tasks are not really anything special (although the compiler builds some magic around them when encountering <code>await</code> keywords), they are just regular reference types, classes. So how about when being called we just remember the task and when called again we first check if it’s still running? If it is, we just return it, and only if it is no longer running we start a new one?</p>
<p>What would a test for this behavior look like?</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">GetTotalSizeAsync_reuses_running_tasks</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> root= Substitute.For&lt;IFolder&gt;();</span><br><span class="line">    <span class="keyword">var</span> underTest= <span class="keyword">new</span> FileSystemFacade(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t1 = <span class="keyword">new</span> Task&lt;<span class="built_in">long</span>&gt;(() =&gt; <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">var</span> t2 = <span class="keyword">new</span> Task&lt;<span class="built_in">long</span>&gt;(() =&gt; <span class="number">17</span>);</span><br><span class="line">    root.GetSizeAsync().Returns(t1, t2);  <span class="comment">// first call returns t1, 2nd t2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// on the first call we should get t1</span></span><br><span class="line">    underTest.GetTotalSizeAsync().Should().Be(t1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make a 2nd call while the 1st is still running</span></span><br><span class="line">    <span class="comment">// should still be t1</span></span><br><span class="line">    underTest.GetTotalSizeAsync().Should().Be(t1); <span class="comment">// HERE</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// now make t1 finish</span></span><br><span class="line">    t1.Start();</span><br><span class="line">    <span class="keyword">await</span> t1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make a 3rd call after the 1st and 2nd have finished</span></span><br><span class="line">    <span class="comment">// this should now be t2</span></span><br><span class="line">    underTest.GetTotalSizeAsync().Should().Be(t2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tidy up</span></span><br><span class="line">    t2.Start();</span><br><span class="line">    <span class="keyword">await</span> t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With the existing implementation, the line marked with <code>// HERE</code> will fail. </p>
<p>So far so good, we got an implementation idea and a failing test. Now let’s make that test pass by changing our implementation:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FileSystemFacade</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> IFolder _rootFolder;</span><br><span class="line">    Task&lt;<span class="built_in">long</span>&gt; _sizeTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... other stuff like the constructor etc.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task&lt;<span class="built_in">long</span>&gt; <span class="title">GetTotalSizeAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_sizeTask != <span class="literal">null</span> &amp;&amp; !_sizeTask.IsCompleted) <span class="keyword">return</span> _sizeTask;</span><br><span class="line">        <span class="keyword">return</span> _sizeTask = _rootFolder.GetSizeAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Et voilà, our test passes.</p>
<p>Of course, doing this means that the latest call to our method does not necessarily get the most up-to-date result. In many scenarios, though, like the disk size visualizer example used, this will not really matter. </p>
</div><div class="tags"><a href="/tags/async/"><i class="fa fa-tag"></i>async</a><a href="/tags/re-entrancy/"><i class="fa fa-tag"></i>re-entrancy</a><a href="/tags/long-running/"><i class="fa fa-tag"></i>long-running</a><a href="/tags/tdd/"><i class="fa fa-tag"></i>tdd</a></div><div class="post-nav"><a class="next" href="/2020/12/13/Integrating-depencency-injection-into-a-legacy-code-base/">Integrating dependency injection into a legacy code base</a></div></div></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Modern Ronin.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo</a> Theme based on <a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo">Maupassant</a> </div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>